# Display lists are designed to be a space-efficient vector format for custom UI
namespace Graphics {
  enum DisplayCommand {
    NONE
    CLEAR
    BEGIN_PATH
    LINE_TO
    CURVE_TO
    FILL_PATH
    STROKE_PATH
  }

  class DisplayListIterator {
    var _list List<double> = null
    var _index = 0

    def reset(list DisplayList) {
      _list = list as List<double>
      _index = 0
    }

    def peek DisplayCommand {
      if _index == _list.count {
        return .NONE
      }

      assert(
        _list[_index] == DisplayCommand.CLEAR ||
        _list[_index] == DisplayCommand.BEGIN_PATH ||
        _list[_index] == DisplayCommand.LINE_TO ||
        _list[_index] == DisplayCommand.CURVE_TO ||
        _list[_index] == DisplayCommand.FILL_PATH ||
        _list[_index] == DisplayCommand.STROKE_PATH)

      return _list[_index] as DisplayCommand
    }

    def advance {
      switch peek {
        case .CLEAR, .FILL_PATH { _index += 2 }
        case .BEGIN_PATH, .LINE_TO, .STROKE_PATH { _index += 3 }
        case .CURVE_TO { _index += 7 }
      }
      assert(_index <= _list.count)
    }

    def clearColor RGBA {
      assert(peek == .CLEAR)
      return _list[_index + 1] as RGBA
    }

    def beginPathX double {
      assert(peek == .BEGIN_PATH)
      return _list[_index + 1]
    }

    def beginPathY double {
      assert(peek == .BEGIN_PATH)
      return _list[_index + 2]
    }

    def lineToX double {
      assert(peek == .LINE_TO)
      return _list[_index + 1]
    }

    def lineToY double {
      assert(peek == .LINE_TO)
      return _list[_index + 2]
    }

    def curveToX1 double {
      assert(peek == .CURVE_TO)
      return _list[_index + 1]
    }

    def curveToY1 double {
      assert(peek == .CURVE_TO)
      return _list[_index + 2]
    }

    def curveToX2 double {
      assert(peek == .CURVE_TO)
      return _list[_index + 3]
    }

    def curveToY2 double {
      assert(peek == .CURVE_TO)
      return _list[_index + 4]
    }

    def curveToX double {
      assert(peek == .CURVE_TO)
      return _list[_index + 5]
    }

    def curveToY double {
      assert(peek == .CURVE_TO)
      return _list[_index + 6]
    }

    def fillPathColor RGBA {
      assert(peek == .FILL_PATH)
      return _list[_index + 1] as RGBA
    }

    def strokePathColor RGBA {
      assert(peek == .STROKE_PATH)
      return _list[_index + 1] as RGBA
    }

    def strokePathThickness double {
      assert(peek == .STROKE_PATH)
      return _list[_index + 2]
    }
  }

  namespace DisplayListIterator {
    const INSTANCE = new
  }

  type DisplayList : List<double> {
    def run(renderer UI.PixelRenderer, originalWidth double, originalHeight double, finalX double, finalY double, finalWidth double, finalHeight double) {
      var iterator = DisplayListIterator.INSTANCE
      var tessellator PathTessellator = null
      iterator.reset(self)

      while true {
        switch iterator.peek {
          case .NONE {
            break
          }

          case .CLEAR {
            assert(tessellator == null)
            renderer.fillRect(finalX, finalY, finalWidth, finalHeight, iterator.clearColor)
          }

          case .BEGIN_PATH {
            assert(tessellator == null)
            tessellator = PathTessellator.new(
              finalX + _split(iterator.beginPathX, originalWidth, finalWidth),
              finalY + _split(iterator.beginPathY, originalHeight, finalHeight),
              renderer.pixelScale)
          }

          case .LINE_TO {
            tessellator.lineTo(
              finalX + _split(iterator.lineToX, originalWidth, finalWidth),
              finalY + _split(iterator.lineToY, originalHeight, finalHeight))
          }

          case .CURVE_TO {
            tessellator.curveTo(
              finalX + _split(iterator.curveToX1, originalWidth, finalWidth),
              finalY + _split(iterator.curveToY1, originalHeight, finalHeight),
              finalX + _split(iterator.curveToX2, originalWidth, finalWidth),
              finalY + _split(iterator.curveToY2, originalHeight, finalHeight),
              finalX + _split(iterator.curveToX, originalWidth, finalWidth),
              finalY + _split(iterator.curveToY, originalHeight, finalHeight))
          }

          case .FILL_PATH {
            renderer.fillPolygon(
              tessellator.finish,
              iterator.fillPathColor)
            tessellator = null
          }

          case .STROKE_PATH {
            renderer.strokePolyline(
              tessellator.finish,
              iterator.strokePathColor,
              iterator.strokePathThickness)
            tessellator = null
          }
        }

        iterator.advance
      }

      assert(tessellator == null)
    }
  }

  namespace DisplayList {
    def new(list List<double>) DisplayList {
      return list as DisplayList
    }

    def _split(value double, original double, final double) double {
      return original == 0 || value < original / 2 ? value : final - original + value
    }
  }
}
